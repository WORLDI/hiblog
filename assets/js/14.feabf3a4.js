(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{565:function(n,t,e){"use strict";e.r(t);var s=e(12),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("hr"),n._v(" "),e("h1",{attrs:{id:"单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[n._v("#")]),n._v(" 单例模式")]),n._v(" "),e("p",[n._v("单例模式是保证一个类只实例化一个对象，并且提供一个能够全局访问这个实例化对象的节点。再次创建实例化对象时，返回之前的实例化对象。")]),n._v(" "),e("p",[e("strong",[n._v("应用场景：")]),n._v("\n主要是控制某些共享资源（如数据库或文件）的访问权限等。"),e("br"),n._v(" "),e("strong",[n._v("实现思路：")])]),n._v(" "),e("ul",[e("li",[n._v("将默认构造函数设为私有，防止其他对象使用单例类的"),e("code",[n._v("new")]),n._v("运算符。")]),n._v(" "),e("li",[n._v("新建一个静态构建方法作为构建函数。该函数会偷偷调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Singleton(name) {\n    this.name = name;\n    this.instance = null;\n\n    this.getName = function() {\n        console.log(this.name);\n    }\n}\n\nSingleton.getInstance = function(name) {\n    if(!this.instance) {\n        this.instance = new Singleton(name);\n    }\n\n    return this.instance;\n}\n\n\nlet single1 = Singleton.getInstance('a');\n\nlet single2 =  Singleton.getInstance('b');\n\nconsole.log(single1 == single2);   // true\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);