(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{571:function(n,a,e){"use strict";e.r(a);var t=e(12),s=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("hr"),n._v(" "),e("h1",{attrs:{id:"javascript作用域与作用域链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript作用域与作用域链"}},[n._v("#")]),n._v(" javascript作用域与作用域链")]),n._v(" "),e("h2",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[n._v("#")]),n._v(" 作用域")]),n._v(" "),e("p",[n._v("最开始的时候，javascript只有全局作用域和函数作用域。全局作用域，顾名思义，全局生效的，在全局作用域下声明的变量为全局变量，在文件里的任何地方都能访问到这个变量；而函数作用域，是在声明函数的时候所创建的作用域，函数作用域内声明的变量，只能在函数内部访问。")]),n._v(" "),e("p",[n._v("后来，es6中新加入了块级作用域的概念，在含有let或const声明的"),e("code",[n._v("{}")]),n._v("被视作一个块级作用域；或者try...catch...也会创建一个块级作用域。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("{\n    var num = 2;\n}\n\nconsole.log('num', num);     // 2\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("{\n    let num = 2;    // or const\n}\n\nconsole.log('num', num);     // ReferenceError: num is not defined\n")])])]),e("p",[n._v("变量与函数的作用域在声明之时就已经决定了。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function a() {\n    console.log(objName);\n}\n\nfunction b() {\n    let objName = 'b';\n    a.call(obj);\n}\n\nlet obj = {\n    objName: 'c',\n}\n\nlet objName = 'global';\n\nb();   // global\n")])])]),e("h2",{attrs:{id:"作用域链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[n._v("#")]),n._v(" 作用域链")]),n._v(" "),e("p",[n._v("全局作用域包含了函数作用域和块级作用域，函数作用域和块级作用域可以嵌套，内层作用域可以访问外层作用域的变量，而外层作用域无法访问到内层作用域的变量。当访问一个变量时，首先会在当前作用域找该变量的声明，找到的话就直接使用，否则再向上层作用域继续找，一直找到全局作用域，这就形成了一条链式的结构，就叫做作用域链。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let simple = 'global';\n\nfunction show() {\n    let simple = 'function';\n\n    return () => {\n        // 先在当前作用域找，找到了，但是没有初始化，报错\n        console.log(simple);\n\n        let simple = 'scope';\n    }\n}\n\nshow()();   // ReferenceError: Cannot access 'simple' before initialization\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let simple = 'global';\n\nfunction show() {\n    let simple = 'function';\n\n    return () => {\n        // 先在当前作用域找，没找到，再到上层作用域找\n        console.log(simple);\n    }\n}\n\nshow()();   // function\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let simple = 'global';\n\nfunction show() {\n    return () => {\n        // 先在当前作用域找，没找到，再到上层作用域找，一直找到全局作用域\n        console.log(simple);\n    }\n}\n\nshow()();   // global\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);