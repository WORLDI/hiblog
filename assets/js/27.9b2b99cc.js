(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{576:function(e,n,t){"use strict";t.r(n);var s=t(12),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("hr"),e._v(" "),t("h1",{attrs:{id:"计算属性-vs-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-vs-方法"}},[e._v("#")]),e._v(" 计算属性 vs 方法")]),e._v(" "),t("p",[e._v("举个🌰，我们想要从下面的数据中筛选出成年的用户进行渲染：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new Vue({\n    data: {\n        users: [\n            {name: 'a', age: 18},\n            {name: 'b', age: 12},\n            {name: 'c', age: 30}\n        ]\n    }\n})\n")])])]),t("p",[e._v("一般有下面这几种方式：")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("v-for")]),e._v(" + "),t("code",[e._v("v-if")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<ul>\n    <li\n        v-for="user in users"\n        v-bind:key="user.name"\n        v-if="user.age >= 18"\n    >{{user.name}}</li>\n</ul>\n')])])]),t("p",[e._v("这样写有点小问题，就是数据源里有多少条数据，模板就会遍历多少次，我们应该给模版仅仅想让它渲染的数据。")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("使用computed计算属性")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<ul>\n    <li\n        v-for=\"user in filteredUser\"\n        v-bind:key=\"user.name\"\n        v-if=\"user.age >= 18\"\n    >{{user.name}}</li>\n</ul>\n\nnew Vue({\n    data: {\n        users: [\n            {name: 'a', age: 18},\n            {name: 'b', age: 12},\n            {name: 'c', age: 30}\n        ]\n    },\n    computed: {\n        filteredUser: function() {        // 这个方法就相当于filteredUser的getter方法\n            return this.users.filter(user => user.age >= 18);\n        }\n    }\n})\n")])])]),t("p",[e._v("这样一来模板拿到的就是过滤后的users了，并且filteredUser是响应式依赖于this.users的，只要this.users一改变，filteredUser也会跟着改变，相当于React中useMemo的效果。")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("使用方法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<ul>\n    <li\n        v-for=\"user in filteredUser()\"\n        v-bind:key=\"user.name\"\n        v-if=\"user.age >= 18\"\n    >{{user.name}}</li>\n</ul>\n\nnew Vue({\n    data: {\n        users: [\n            {name: 'a', age: 18},\n            {name: 'b', age: 12},\n            {name: 'c', age: 30}\n        ]\n    },\n    methods: {\n            filteredUser: function() {\n                return this.users.filter(user => user.age >= 18);\n        }\n    },\n})\n")])])]),t("p",[e._v("从表现来看，使用computed和方法的最终结果是一样的。然而，不同的是"),t("strong",[e._v("计算属性是基于它们的响应式依赖进行缓存的")]),e._v("。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 this.users 还没有发生改变，多次访问 filteredUser 计算属性会立即返回之前的计算结果，而不必再次执行函数。")]),e._v(" "),t("p",[t("strong",[e._v("为什么需要缓存？")]),e._v("\n假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。")]),e._v(" "),t("h2",{attrs:{id:"watch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[e._v("#")]),e._v(" watch")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new Vue({\n    el: '#app',\n    data: {\n        input: '',\n        result: []\n    },\n    watch: {           \n        input: function(newInput, oldInput) {        // 如果this.input发生变化，这个方法就会执行\n            this.getData();\n        }\n    },\n    created: function() {\n        this.getData = debounce(this.getResult, 500);\n    },\n    methods: {\n        getResult: function() {\n            axios({\n                method: 'POST',\n                url: 'xxx',\n                data: {\n                    input,\n                }\n            }).then(res => {\n                this.result = [...res];\n            })\n        }\n    }\n})\n")])])]),t("p",[e._v("按照我的理解来说，"),t("code",[e._v("computed")]),e._v("计算属性相当于React中的"),t("code",[e._v("useMemo")]),e._v("，"),t("code",[e._v("watch")]),e._v("属性相当于React中的"),t("code",[e._v("useEffect")]),e._v("。")])])}),[],!1,null,null,null);n.default=a.exports}}]);