(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{575:function(a,e,s){"use strict";s.r(e);var t=s(12),n=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("hr"),a._v(" "),s("h1",{attrs:{id:"var-let-const-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#var-let-const-的区别"}},[a._v("#")]),a._v(" var/let/const 的区别")]),a._v(" "),s("ul",[s("li",[a._v("var在全局作用域中定义的变量会被挂载到"),s("code",[a._v("window")]),a._v("对象下，而let和const则不会")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var simple = 'var';\nconsole.log(window.simple);   // var\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let simple = 'let';\nconsole.log(window.simple);   // undefined\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const simple = 'const';\nconsole.log(window.simple);   // undefined\n")])])]),s("ul",[s("li",[a._v("var声明的变量存在变量提升，而let和const声明的变量不存在变量提升。所谓变量提升，就是变量声明会提升到当前作用域的最顶层。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function simple() {\n    console.log(obj);\n\n    var obj = { name: 'haha' };\n}\n\nsimple();     // undefined\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function simple() {\n    console.log(obj);\n\n    let obj = { name: 'haha' };     // or const\n}\n\nsimple();     // ReferenceError: Cannot access 'obj' before initialization\n")])])]),s("ul",[s("li",[a._v("var可以声明同名变量，而let和const在同一作用域下不能声明同名变量，会报错。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function simple() {\n    var obj = 1;\n   \n    var obj = { name: 'haha' };\n    console.log(obj);        // { name: 'haha' }\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function simple() {\n    let obj = 1;     // or const\n   \n    let obj = { name: 'haha' };   // SyntaxError: Identifier 'obj' has already been declared\n    console.log(obj);\n}\n")])])]),s("ul",[s("li",[s("p",[a._v("var声明的是全局变量或者函数变量，而let和const还可以声明块级变量，只在块即作用域内生效。")])]),a._v(" "),s("li",[s("p",[a._v("var和let可以先声明，后初始化，而const必须在声明的时候就初始化变量。")])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var obj;    // no problem\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let obj;    // no problem\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const obj;   // SyntaxError: Missing initializer in const declaration\n")])])]),s("ul",[s("li",[a._v("var和let声明的变量可以改变，而const定义的常量值不可改变，定义的变量在内存中指向的地址不可改变。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let simple = {        // or var\n    type: 'let',\n}\n\nsimple = {\n    name: 'none',\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const simple = 1;\nsimple = 2;     // TypeError: Assignment to constant variable.\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const simple = {\n    type: 'const',\n}\nsimple.type  = 'none';     // no problem\nsimple = {             // TypeError: Assignment to constant variable.\n    name: 'simple',\n}\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);